\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1in]{geometry}

\usepackage{tikz}

\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\mtx}{\mathbf}


\begin{document}
\title{ Left-Looking (\& Variants) Sparse LU Factorization}
\maketitle


\section{Résolution d'un système $y \cdot M = x$}
On dispose d'une suite de matrices $L_0, L_1, \ldots, L_N$
trapézoidales inférieures permutées qui représentent la matrice
$M$. On rappelle que $M$ est carrée de taille $n \times n$.
(attention, certains de ces $L_k$ peuvent être vides, dans ce cas, les
matrices ne sont pas stockées). On suppose que pour chacune de ses
matrices $L_k$, on dispose d'une permutation \verb$q_k$ telle que pour
toute colonne \verb$j$ de $L_k$, \verb$q_k[j]$ est l'indice de la
colonne correspondante dans $M$.

De plus on dispose d'un tableau \verb$T$ tel que pour tout \verb$i$,
$0 \leq \verb|i| < n$, $\verb|T[i]| = k$ implique que la ligne
\verb$i$ de $M$ est représenté dans la matrice $L_k$ (il n'y en a
qu'une seule). Si $k = -1$ alors \verb$i$ appartient à un "bloc
d'identité". On dispose également d'une permutation \verb$rinv$ telle
que \verb$rinv[i] = i_new$ implique que l'indice de la ligne \verb$i$
dans la matrice $L_k$ est \verb$i_new$, si $\verb|T[i]| = k \not= -1$.
On ne regardera jamais la valeur de \verb$rinv[i]$ dans le cas où
\verb$T[i]$ sera négatif.

Ceci étant dit, on peut écrire l'ébauche d'un algorithme qui recherche
le support de $y$ :

\subsection{Problèmes autour de \texttt|T| et \texttt|rinv|}

On possède, pour chaque matrice $M$ (donc chaque diagonale), une liste
des matrices $L_k$ qui sont présentes. Chaque matrice $L_k$ est munie
d'un tableau \verb|r| tel que \verb|r[i]| donne l'indice dans la
matrice $M$ de la ligne qui correspond à la $i$-ème ligne de $L_k$.

On ne peut pas stocker les vecteurs  \verb|T| et \verb|rinv| pour
chaque diagonale, car cela pourrait nécessiter l'espace de
$\mathcal{O}(n)$ vecteurs denses.

Je propose la technique suivante : au début du calcul on alloue
\emph{un} vecteur  \verb|T|, \emph{un} vecteur \verb|rinv|. Ces
tableaux sont initialement initalisés avec des $-1$.

Au début du traitement de chaque matrice $M$, on met dedans les
valeurs adaptées à cette matrice $M$. Une fois que le traitement de
$M$ est fini, on restaure les deux vecteurs dans l'état d'origine.

Ceci se fait de la façon suivante.  Pour chacune des matrices $L_k$
présente dans la diagonale, on itère sur la permutation \verb|r|
associée à la matrice. On sait donc que la $i$-ème ligne de $L_k$ est
la $j$-ème ligne de $M$. On fixe \verb|T[j] = k| et \verb|rinv[j] = i|.

Une fois que les calculs avec $M$ sont finis, on refait le même
cirque que précédement, mais en mettant des $-1$ dans les cases des
tableaux. Du coup, une fois le processus terminé, les tableaux sont
revenus dans l'état initial.

Ceci est peut-être optimisable, en considérant qu'il suffit de
s'occuper des indices $i$ qui apparaissent dans le support du membre
droit. En effet, il y a un risque que les opérations précédentes
dominent l'ensemble du processus de résolution de $x \cdot M = y$ dans
certains cas ($y$ très très très creux).

Le seul moyen que je vois de contourner ce problème consiste à
déterminer quelles matrices $L_k$ ``rencontrent'' le support du membre
droit $y$, et de ne ``dispatcher'' QUE ces matrices-là dans les
vecteurs \verb|T| et \verb|rinv|. 

Et pour déterminer quelles matrices $L_k$ rencontrent le support de
$y$ ? Il faudrait disperser les indices $k$ qui sont présents dans un
tableau, puis itérer sur le support de $y$ (on a des indices de
lignes). Déterminer pour chacun à quel intervalle de lignes il
appartient, et si on tombe sur un des $k$ répertoriés, on traite
$L_k$, et on la marque comme traitée (pour ne pas la traiter deux fois).

\subsection{Algorithme "de base" :}

\begin{algorithmic}
\Require right-hand side $x$, matrices $L_0, \ldots, L_N$, permutations \verb$q_0$, ..., \verb$q_N$, \verb$rinv$, table \verb$T$.
\Ensure $\mathcal{Y}$, $y$'s pattern.
\State assume all nodes $j$ are unmarked
\ForAll{$j$ s.t. $x_j \not = 0$}
\If{$j$ is unmarked}
\State $k \gets \verb|T[j]|$
\If{$k = -1$}
\State push $j$ onto stack for $\mathcal{Y}$
\Else
\State $i \gets \verb|r_inv[j]|$
\State $\textsc{dfs}(i, L_k)$
\EndIf
\EndIf
\EndFor   
\end{algorithmic}   

\begin{algorithmic}
\Procedure{dfs}{$i, L_k$}
\State mark node \verb$q_k[i]$ \Comment Ceci n'est pas exactement vrai (voir en dessous)
\ForAll{$j$ s.t. $L_k[i:j] \not= 0$}
\If{$\mathtt{q\_k[j]}$ unmarked}
\State $\textsc{dfs}(j, L_k)$
\EndIf
\State push \verb$q_k[i]$ onto stack for $\mathcal{Y}$
\EndFor
\EndProcedure
\end{algorithmic}

À noter que cet algorithme ne prend pas en compte les permutations et l'aspect "trapézoïdale" des matrices $L_k$.
Dans le cas idéal (décrit par l'algorithme au dessus), pour tout $0 \leq j < N$, \verb$q_k[rinv[j]] = j$, dans notre cas, nos matrices ne sont pas carrées et les lignes sont de plus permutées, donc ce n'est pas aussi simple.
Les deux problèmes doivent sans doute pouvoir se régler ensemble en considérant une (ou plusieurs) autre(s) "bonne(s)" permutation(s) (la fonction \verb$dfs$ déjà implémentée fait déjà cela dans une certaine mesure avec la permutation \verb$pinv$). 

\subsection{À faire :} 
\begin{enumerate}
\item Reprendre la fonction \verb$dfs$ afin qu'elle prennent en compte les nouvelles permutations.
\item Créer une nouvelle fonction \verb$extended_reach$, qui détermine le support d'une solution d'un système défini par plusieurs matrices.
\item Écrire une fonction qui résout un tel système, et la tester.
\end{enumerate}

\section{Problème du stockage des données}

Il faut éviter de stocker le tableau \verb$T$ tel qu'il est décrit plus haut. On peut remarquer que si une ligne $i$ est sur un intervalle de ligne $I_k$, alors \verb$T[i] = k$ ou \verb$T[i] = -1$, et ce pour n'importe quelle diagonale $d$ (les lignes des matrices $L_k$, correspondent à un sous-ensemble des lignes de l'intervalle $I_k$, les colonnes de $L_k$ en revanche peuvent s'étaler sur plusieurs intervalles de colonnes).

Ce qu'il faudrait c'est un tableau \verb$T_x$ qui pour chaque $i$ tel que $x_i \not= 0$ (on rappelle que $x$ est le second membre de l'équation, et son support $\mathcal{X}$ est connu), nous renvoie un certain indice $t \geq 0$ si $i$ est représentée dans la matrice de son intervalle de ligne, et $-1$ sinon.
L'indice $t$ renvoyé dans le premier cas correspond à un pointeur sur la matrice $L_k$.

Concrètement, il faut former le tableau \verb$T_x$ au moment où on forme $x$. 
Dans le cas où $x$ est un vecteur canonique $e_i$, avec $i \in I_k$, $k$ connu. Il suffit de regarder si la matrice $L_{d,k}$ existe et le cas échéant si la ligne $i$ est bien représentée. (soit en disposant de la permutation \verb$rinv$ avec \verb$rinv[i] = -1$ si $i$ n'est pas représentée, soit en parcourant les lignes de $L_{d,k}$).

Dans le cas où $x$ résulte d'un système résolu précédemment, c'est plus délicat. On peut soit former \verb$T_x$ au moment où on écrit le support (mais cela impliquerait qu'on modifie encore d'avantage la fonction \verb$dfs$ et entraînerait, il me semble, des complications), soit au moment où on calcule le coefficient $x_i$ (ce qui me parait être moins contraignant).


\end{document}