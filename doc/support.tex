\documentclass{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1in]{geometry}

\usepackage{tikz}

\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\mtx}{\mathbf}


\begin{document}
\title{ Left-Looking (\& Variants) Sparse LU Factorization}
\maketitle


\section{Résolution d'un système $y \cdot M = x$}
On dispose d'une suite de matrices $L_0, L_1, /ldots, L_N$ trapézoidales inférieures permutées qui représentent la matrice $M$. On rappelle que $M$ est carrée de taille $n \times n$. (attention, certains de ces $L_k$ peuvent être vides, dans ce cas, les matrices ne sont pas stockées). On suppose que pour chacune de ses matrices $L_k$, on dispose d'une permutation \verb$q_k$ telle que pour toute colonne \verb$j$ de $L_k$, \verb$q_k[j]$ est l'indice de la colonne correspondante dans $M$.

De plus on dispose d'un tableau \verb$T$ tel que pour tout \verb$i$, $0 /leq \verb|i| < n$, $\verb|T[i]| = k$ implique que la ligne \verb$i$ de $M$ est représenté dans la matrice $L_k$ (il n'y en a qu'une seule). Si $k = -1$ alors \verb$i$ appartient à un "bloc d'identité". On dispose également d'une permutation \verb$rinv$ telle que \verb$rinv[i] = i_new$ implique que l'indice de la ligne \verb$i$ dans la matrice $L_k$ est \verb$i_new$, si $\verb|T[i]| = k \not= -1$. On ne regardera jamais la valeur de \verb$rinv[i]$ dans le cas où \verb$T[i]$ sera négatif.

Ceci étant dit, on peut écrire l'ébauche d'un algorithme qui recherche le support de $y$ :

\subsection{Algorithme "de base" :}

\begin{algorithmic}
\Require right-hand side $x$, matrices $L_0, \ldots, L_N$, permutations \verb$q_0$, ..., \verb$q_N$, \verb$rinv$, table \verb$T$.
\Ensure $\mathcal{Y}$, $y$'s pattern.
\State assume all nodes $j$ are unmarked
\ForAll{$j$ s.t. $x_j \not = 0$}
\If{$j$ is unmarked}
\State $k \gets \verb|T[j]|$
\If{$k = -1$}
\State push $j$ onto stack for $\mathcal{Y}$
\Else
\State $i \gets \verb|r_inv[j]|$
\State $\textsc{dfs}(i, L_k)$
\EndIf
\EndIf
\EndFor   
\end{algorithmic}   

\begin{algorithmic}
\Procedure{dfs}{$i, L_k$}
\State mark node \verb$q_k[i]$ \Comment Ceci n'est pas exactement vrai (voir en dessous)
\ForAll{$j$ s.t. $L_k[i:j] \not= 0$}
\If{$\mathtt{q\_k[j]}$ unmarked}
\State $\textsc{dfs}(j, L_k)$
\EndIf
\State push \verb$q_k[i]$ onto stack for $\mathcal{Y}$
\EndFor
\EndProcedure
\end{algorithmic}

À noter que cet algorithme ne prend pas en compte les permutations et l'aspect "trapézoïdale" des matrices $L_k$.
Dans le cas idéal (décrit par l'algorithme au dessus), pour tout $0 \leq j < N$, \verb$q_k[rinv[j]] = j$, dans notre cas, nos matrices ne sont pas carrées et les lignes sont de plus permutées, donc ce n'est pas aussi simple.
Les deux problèmes doivent sans doute pouvoir se régler ensemble en considérant une (ou plusieurs) autre(s) "bonne(s)" permutation(s) (la fonction \verb$dfs$ déjà implémentée fait déjà cela dans une certaine mesure avec la permutation \verb$pinv$). 

\subsection{À faire :} 
\begin{enumerate}
\item Reprendre la fonction \verb$dfs$ afin qu'elle prennent en compte les nouvelles permutations.
\item Créer une nouvelle fonction \verb$extended_reach$, qui détermine le support d'une solution d'un système défini par plusieurs matrices.
\item Écrire une fonction qui résout un tel système, et la tester.
\end{enumerate}

\section{Problème du stockage des données}

Il faut éviter de stocker le tableau \verb$T$ tel qu'il est décrit plus haut. On peut remarquer que si une ligne $i$ est sur un intervalle de ligne $I_k$, alors \verb$T[i] = k$ ou \verb$T[i] = -1$, et ce pour n'importe quelle diagonale $d$ (les lignes des matrices $L_k$, correspondent à un sous-ensemble des lignes de l'intervalle $I_k$, les colonnes de $L_k$ en revanche peuvent s'étaler sur plusieurs intervalles de colonnes).

Ce qu'il faudrait c'est un tableau \verb$T_x$ qui pour chaque $i$ tel que $x_i \not= 0$ (on rappelle que $x$ est le second membre de l'équation, et son support $\mathcal{X}$ est connu), nous renvoie un certain indice $t \geq 0$ si $i$ est représentée dans la matrice de son intervalle de ligne, et $-1$ sinon.
L'indice $t$ renvoyé dans le premier cas correspond à un pointeur sur la matrice $L_k$.

Concrètement, il faut former le tableau \verb$T_x$ au moment où on forme $x$. 
Dans le cas où $x$ est un vecteur canonique $e_i$, avec $i \in I_k$, $k$ connu. Il suffit de regarder si la matrice $L_{d,k}$ existe et le cas échéant si la ligne $i$ est bien représentée. (soit en disposant de la permutation \verb$rinv$ avec \verb$rinv[i] = -1$ si $i$ n'est pas représentée, soit en parcourant les lignes de $L_{d,k}$).

Dans le cas où $x$ résulte d'un système résolu précédemment, c'est plus délicat. On peut soit former \verb$T_x$ au moment où on écrit le support (mais cela impliquerait qu'on modifie encore d'avantage la fonction \verb$dfs$ et entraînerait, il me semble, des complications), soit au moment où on calcule le coefficient $x_i$ (ce qui me parait être moins contraignant).


\end{document}